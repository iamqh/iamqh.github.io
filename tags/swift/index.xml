<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>swift on iamqh's Blog</title><link>iamqh.github.io/tags/swift/</link><description>Recent content in swift on iamqh's Blog</description><generator>Hugo -- gohugo.io</generator><language>vi-vn</language><lastBuildDate>Tue, 16 Jun 2020 08:59:47 +0000</lastBuildDate><atom:link href="iamqh.github.io/tags/swift/index.xml" rel="self" type="application/rss+xml"/><item><title>Ngăn ngừa Memory leaks bằng autoreleasepool trong unit test</title><link>iamqh.github.io/posts/autoreleasepool-unit-test/</link><pubDate>Tue, 16 Jun 2020 08:59:47 +0000</pubDate><guid>iamqh.github.io/posts/autoreleasepool-unit-test/</guid><description>Memory leaks thường xảy ra mà không có bất cứ thông báo nào. Mặc dù việc sử dụng weak reference cho self trong các closure đã giúp ích rất nhiều, nhưng như thế là chưa đủ. Chúng ta có thể sử dụng memory graph debugging hoặc Xcode Instruments để tìm và giải quyết các lỗi về bộ nhớ. Nhưng nó khá phức tạp và tốn nhiều thời gian.
Rất may là chúng ta có một cách đơn giản hơn, là bằng cách sử dụng unit test.</description></item><item><title>Hiểu về Copy-on-Write trong Swift</title><link>iamqh.github.io/posts/copy-on-write/</link><pubDate>Sun, 17 May 2020 08:59:47 +0000</pubDate><guid>iamqh.github.io/posts/copy-on-write/</guid><description>Trong Swift, ta có kiểu reference type (Class) và value type (Struct, Tuble, enum). Kiểu value type có bản chất là copy. Có nghĩa là nếu bạn gán một value type cho một biến hoặc pass nó như một parameter của function (không phải inout), dữ liệu của value type này sẽ được copy. Lúc này, bạn sẽ có 2 value type có nội dung giống nhau nhưng có 2 địa chỉ bộ nhớ riêng biệt.</description></item></channel></rss>